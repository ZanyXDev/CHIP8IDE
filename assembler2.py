
'''

    The Forward-reference problem!

We do want to support forward references, e.g.

    CALL DO_SUB
    ...
DO_SUB: ...

The problem is that we cannot know the value of any label such as DO_SUB, or
keep an accurate symbol table, while editing is going on. As long as the user
is free to change any statements while editing, the user can:

* Delete the CALL line, removing what might be the only reference to DO_SUB
from the program.

* Insert or delete any number of statements between the CALL and the label,
changing the value of DO_SUB.

* Delete the DO_SUB line and replace it at point in the program above or
below the CALL at any future time.

* Enter a duplicate DO_SUB label, then maybe go back to delete one.

Note especially in the case of deleting, we get no signal that a delete has
occurred. The QSyntaxHighlighter is called to validate new and modified
lines, but there is no call from the editor when a line (or lines) are
deleted.

The only solution is to provide buttons "Check" and "Load" which the user
clicks and we take as meaning, no editing is happening at least for a while.

Then we can do the classic two-pass assembly: on pass 1, note the values of
all labels based on the known byte-count generated by all instructions. Then
on pass 2, actually evaluate all expressions and complete the assembly.

That's fine except for...

    The ORG problem!

ORG says, move the assembler's output pointer to a different address. The
problem is, that potentially changes the value of all following labels.
Consider:

    ORG BUF+#80
BUF DS #80

Other pathological examples can be concocted. My first thought was, why
support ORG at all? Is it really used? Would anybody miss it? Well, maybe and
probably. So, how to tame it? The problem is making it deterministic, which
means: Ensure that all labels named in an ORG expression are defined.

This means that on assembly pass 1, the expression operand of ORG
must be evaluated and an error raised unless it is defined.

'''