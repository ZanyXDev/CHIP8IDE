__license__ = '''
 License (GPL-3.0) :
    This file is part of CHIP8IDE.

    CHIP8IDE is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You can find a copy of the GNU General Public License in the file
    COPYING.TXT included in the distribution of this program, or see:
    <http://www.gnu.org/licenses/>.
'''
__version__ = "1.0.0"
__author__  = "David Cortesi"
__copyright__ = "Copyright 2016 David Cortesi"
__maintainer__ = "David Cortesi"
__email__ = "davecortesi@gmail.com"

'''
    Statement class

This class is used by source, assembler1, and assembler2 to record the
contents and value of one assembler statement. The Statement object contains
everything needed to complete the assembly of that statement.

Each statement in the source file normally has an object of this class
associated with it. A new instance is created if necessary, on a call to
phase_one(), from the syntax highlighter. It is stored as the userData() of
the QTextBlock for that line.

'''

class Statement():
    '''
    Apply the Python __slots__ dict to speed access and limit the
    memory size of objects of this class. For pros and cons, refer to
    https://docs.python.org/3.5/reference/datamodel.html#object.__slots__
    '''
    __slots__ = [ 'text_error', 'expr_error', 'error_pos', 'error_msg',
                  'form', 'defined_name', 'reg_1', 'reg_2',
                  'next_pc', 'expressions', 'value', 'value_dump', 'PC' ]

    def __init__( self ) :
        '''
        Does this statement have any errors? text_error is set by the
        phase_one syntax scan. expr_error is set during assembly.
        '''
        self.text_error = False
        self.expr_error = False
        '''
        When the statement is marked as an error, error_pos is set to the
        column where it went wrong, if we know it; else to zero. An error
        message is supplied as well. "error_pos is None" is a test for a
        valid statement.
        '''
        self.error_pos = None
        self.error_msg = ''
        '''
        When the statement is recognized by signature_dict or signature_regex
        in assembler1.py, self.form is the instruction code found. If the
        statement was not recognized, self.form is a null string and
        self.text_error is True.
        '''
        self.form = ''
        '''
        Does this statement define a name? It does if there is a label at the
        head of this line, or if the statement is an EQU. Note that the value
        of the name is not stored here; it is determined in in the second
        phase (assembler2.py), at which time it is stored in the symbol table
        for access from expression evaluation. So the defined value is never
        needed in the Statement object, only the fact that is does define one.
        '''
        self.defined_name = ''
        '''
        When any operand is a register, its index (as defined in the chip8.R
        enumeration) is in one of these fields.
        '''
        self.reg_1 = None # reg named in first operand if any
        self.reg_2 = None # reg named in second operand if any
        '''
        What should the PC be after this statement? It could be unchanged (a
        comment or an error line), incremented by 2 (a typical instruction)
        incremented by 1 or more (DS, DB, DA), or set to a completely new
        value (ORG).

        When .form == 'ORG', set the PC to this value. In all other cases,
        add this value to the PC.
        '''
        self.next_pc = 0
        '''
        Only two instructions can have more than one expression (DB, DW).
        The rest have at most one. In any case, all expressions are stored
        here as a list of Python code objects, one per expression.
        '''
        self.expressions = []
        '''
        The number of generated bytes can always be known when a statement is
        entered, but the actual bytes cannot be known until phase two
        timeÂ (for some types of statement). After the value is known it is
        stored here.
        '''
        self.value = [] # list of bytes generated
        self.value_dump = '' # display form
        '''
        After assembly the value of the PC where this statement will load
        is stored here.
        '''
        self.PC = None

    '''
    Call this method to initialize the Statement prior to a lexical scan.
    Clear fields used during the lexical scan, including any error.
    '''
    def init_static( self ) :
        self.text_error = False
        if not self.expr_error :
            self.error_msg = ''
        self.error_pos = None
        self.form = ''
        self.defined_name = ''
        self.reg_1 = None
        self.reg_2 = None
        self.next_pc = 0
        self.expressions = []
    '''
    Call this method to initialize the Statement prior to the phase-2 scan.
    Clear fields set during assembly, and an expression error if any. Don't
    clear text_error or error_msg or error_pos; those are either clear
    already, or they reflect a lexical error.
    '''
    def init_assembly( self ) :
        self.expr_error = False
        self.value = []
        self.value_dump = ''
        self.PC = None
